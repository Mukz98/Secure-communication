#include <stdio.h>
#include <string.h>
#include <PS2Keyboard.h>
#include <LiquidCrystal_I2C.h>
#include <Wire.h>


PS2Keyboard keyb;
LiquidCrystal_I2C lcd(0x27,2,1,0,4,5,6,7,3,POSITIVE);


bool isPasswordDone;
bool isReceiveKeyPressed;
const int key_length = 256;
const int num_of_key_bytes = key_length/8 ;
const int key_row_len = 4;
const int key_col_len = num_of_key_bytes/key_row_len;
const int text_row_len = 4;
const int text_col_len = 4;

/****ADDED PARAMETERS***/
const int block_size = 4;
const int num_of_rounds = 14;


//word wds[(num_of_rounds+1)*block_size*2];

const int block_len = 16;
const int key_len = 32;


const static byte Sbox[256] PROGMEM ={
  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,
} ;


/*****************S-BOX USED FOR DENCRYPTION*********************/
const static byte decryption_S_BOX[256] PROGMEM=  {82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251,
                                  124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203,
                                  84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78,
                                  8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37,
                                  114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146,
                                  108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132,
                                  144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6,
                                  208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107,
                                  58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115,
                                  150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110,
                                  71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27,
                                  252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244,
                                  31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95,
                                  96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239,
                                  160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97,
                                  23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125};


const static byte mul2[256] PROGMEM = 
{0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5};

const static byte mul3[256] PROGMEM =
{
0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,
0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,
0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,
0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,
0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a
};

 
const byte mul9[256] PROGMEM= 
{
    0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
    0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,
    0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,
    0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,
    0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,
    0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,
    0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,
    0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,
    0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,
    0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,
    0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,
    0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,
    0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,
    0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,
    0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,
    0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46
};

const byte mul11[256] PROGMEM= 
{
    0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,
    0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,
    0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,
    0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,
    0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,
    0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,
    0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,
    0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,
    0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,
    0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,
    0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,
    0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,
    0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,
    0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,
    0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,
    0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3
};

const byte mul13[256] PROGMEM= 
{
    0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,
    0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,
    0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,
    0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,
    0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,
    0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,
    0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,
    0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,
    0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,
    0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,
    0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,
    0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,
    0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,
    0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,
    0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,
    0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97
};

const byte mul14[256] PROGMEM= 
{
    0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,
    0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,
    0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,
    0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,
    0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,
    0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,
    0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,
    0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,
    0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,
    0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,
    0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,
    0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,
    0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,
    0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,
    0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,
    0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d
};

void key_expansion(const byte exple_ky[], byte words[4][60],const byte Sbox[256]){
  
  for(int i = 0; i< key_col_len; i++){

        for(int j=0; j<block_size; j++){
          words[j][i] = exple_ky[4*i+j];          
          }
    
    }

  byte temp[4];
  byte RC[12];
 

  RC[1] = 0x01;

  for(int i=key_col_len; i<(14+1)*4; i++){

      temp_subArray(temp,words,(i-1));

      if((i%key_col_len)==0){
        
          roWord(temp);
          subWord(temp,Sbox,4);
          if(i/key_col_len !=1){
            RC[i/key_col_len] = 0x2*RC[i/key_col_len -1];
            }

            xoring(temp,RC[i/key_col_len]);
 
        }
        
else if (key_col_len > 6 && (i%key_col_len)== 4)
        subWord(temp,Sbox,4);

    for(int x=0; x< 4; x++){

        words[x][i] = words[x][i-key_col_len]^temp[x];
      }
 
    
    }
  
  }




 void temp_subArray(byte tmp[], byte wor[4][60], int j){
  
        for(int i=0; i<4; i++)
          tmp[i] = wor[i][j];
      
  }





void roWord(byte tmp[]){

  byte temp;
  for(int i=0; i< 3; i++){
    temp = tmp[i+1];
    tmp[i+1] = tmp[i];
    tmp[i] = temp;
    }
  
  }



void subWord(byte tmp[],const byte Sbox[256],int ending){

  for(int i=0; i< ending; i++){
    
    tmp[i] =  pgm_read_byte_near(Sbox+tmp[i]);
    }
  
  }
  

void xoring(byte tmp[], byte RC){

  tmp[0] = tmp[0]^RC;
  for(int i=1; i< 4; i++){
    
        tmp[i] = tmp[i]^0x00;
    }
  
  }


void one2two_D(byte arr_1D[],byte  arr_2D[][4]){
    unsigned int x = 0;

    for(unsigned int i = 0; i< 4; i++){
        for(unsigned int j = 0; j< 4; j++){
            arr_2D[j][i] = arr_1D[x];
            x++;
          }
      }
  }



/******************************************************************************END KEY EXPANSION***********************************************************/
/*********************************************************************************************************************************************************/

void rotWord(byte tmp[][4],int row){

  byte temp;
  for(int i=0; i< 3; i++){
    temp = tmp[row][i+1];
    tmp[row][i+1] = tmp[row][i];
    tmp[row][i] = temp;
    }
  
  }
void AddRoundKey1(byte s[][4],byte w[][4],int dims)
{

  for(int i=0;i<dims;i++)

  
  {
    for (int j=0;j<4;j++)
    {
      s[i][j]=w[i][j]^s[i][j];
    }
  }



 }

void Substitutebytes(byte s[][4], const byte sbox[256],int dims)
{

  //byte **ss;
  
    for(int i=0;i<dims;i++)
  
  {
    for (int j=0;j<dims;j++)
    {
      s[i][j]=pgm_read_byte_near(sbox+s[i][j]);
    }
  }

//return ss;
  
}

void Shiftrows(byte s[][4])
{
  for(int i=0;i<4;i++)
  {
    for(int j=0;j<i;j++)
    {
      rotWord(s,i);
    }
  }

  
  
}

void Lastround(byte s[][4], const byte sbox[256],int dims,byte w[][4])
{

  Substitutebytes(s,sbox,dims);
  Shiftrows(s);
  //AddRoundKey1(s,w,dims);
 
}

void EncrptnRounds(byte s[][4],const byte mul2[256],const byte mul3[256],int dims,byte w[][4],const byte sbox[256])
{ 
  Substitutebytes(s,sbox,dims);
  Shiftrows(s);
  MixColunms(s,mul2,mul3,dims);
 
}

void MixColunms(byte s[4][4],const byte mul2[256],const byte mul3[256],int dims)
{

  
  byte ss[4][4];
 
    for (int j=0;j<dims;j++)
    {
     
      
      ss[0][j] = pgm_read_byte_near(mul2+s[0][j])^pgm_read_byte_near(mul3+s[1][j])^s[2][j]^s[3][j];
      ss[1][j] = s[0][j]^pgm_read_byte_near(mul2+s[1][j])^pgm_read_byte_near(mul3+s[2][j])^s[3][j];
      ss[2][j] = s[0][j]^s[1][j]^pgm_read_byte_near(mul2+s[2][j])^pgm_read_byte_near(mul3+s[3][j]);
      ss[3][j] = pgm_read_byte_near(mul3+s[0][j])^s[1][j]^s[2][j]^pgm_read_byte_near(mul2+s[3][j]);

      
    }
     
    for(int i=0;i<4;i++)
  {
    for (int j=0;j<4;j++)
    {
      s[i][j] = ss[i][j];
    }
   
  }
  
//return ss;
}

void Encryption(byte AllKeys[4][60] ,byte text [][4])
{
  int x =4;
int b; //key colunm
byte key[4][4];
for(int i=1;i<16;i++)
{
   b=0;
  
  // Key for the current round
  for(int j=((4*i)-4);j<(((4*i)-4)+4);j++)
  {
    for(int k=0;k<4;k++)
    {
      key[k][b] = AllKeys[k][j];
      
  
    }
    b++;
   
  }


  AddRoundKey1(text,key,x);
  


   


//rounds starts 
if( i<14)
{
  EncrptnRounds(text,mul2,mul3,x,key,Sbox);
  }
else if(i==14){
  Lastround(text,Sbox,x,key);
  }
 

}
}



/********************************Decrytion functions*****************************************/
void decryption (byte cipher[], const byte wor[4*(14+1)*4]){




  //output_matrix(wor,block_len*num_of_rounds*block_len);
  addRoundKey(cipher, wor,block_size*num_of_rounds*block_size);


  for(byte rounds = num_of_rounds-1; rounds>=1; rounds--){

   
      shift_rows_inverse(cipher);    
      subWord(cipher,decryption_S_BOX,16);
      addRoundKey(cipher, wor,block_size*rounds*block_size);
      mixColumns_inverse(cipher);
      //output_matrix(cipher,0);
    }

      shift_rows_inverse(cipher);
      subWord(cipher,decryption_S_BOX,16);
      addRoundKey(cipher, wor,0);


  
  }



void addRoundKey(byte cipher[], const byte wor[],byte start){

  for(byte i=0; i<block_size*block_size; i++)
    cipher[i] = cipher[i]^wor[i+start];
  
  }


void transfer_array_values(byte temp[], byte arr[]){
  
     for(byte i=0; i<16; i++)
        arr[i] = temp[i];
  
  }

  
void shift_rows_inverse(byte cipher[]){
  
    byte temp[16];
    temp[0] = cipher[0];
    byte n = 0, k=1;

    for(byte i=1; i<16; i++){
      
      temp[5*k-n] = cipher[i];
      k++;

      if(i%3==0){
        n++;
        k=1;
        }
      }
 transfer_array_values(temp,cipher);
 
  }


 void mixColumns_inverse(byte cipher[]){
    
  
  byte temp1,temp2, temp3, temp4;
  
  for(byte i = 0; i<=12; i+=4){

        temp1 = cipher[0+i];
        temp2 = cipher[1+i];
        temp3 = cipher[2+i];
        temp4 = cipher[3+i];
        
    
        cipher[0+i] =pgm_read_byte_near(mul14+temp1)^pgm_read_byte_near(mul11+temp2)^pgm_read_byte_near(mul13+temp3)^pgm_read_byte_near(mul9+temp4);
        cipher[1+i] = pgm_read_byte_near(mul9+temp1)^pgm_read_byte_near(mul14+temp2)^pgm_read_byte_near(mul11+temp3)^pgm_read_byte_near(mul13+temp4);
        cipher[2+i] = pgm_read_byte_near(mul13+temp1)^pgm_read_byte_near(mul9+temp2)^pgm_read_byte_near(mul14+temp3)^pgm_read_byte_near(mul11+temp4);
        cipher[3+i] = pgm_read_byte_near(mul11+temp1)^pgm_read_byte_near(mul13+temp2)^pgm_read_byte_near(mul9+temp3)^pgm_read_byte_near(mul14+temp4);
    }


    
    }

 void output_matrix(byte tested_matrix[], byte initial){
  
    for(byte i=initial; i<16+initial; i++){
    
    Serial.print(tested_matrix[i],HEX);
    Serial.print(F("  "));
    }
      Serial.println();
     Serial.println(F("Done"));
    Serial.println();
  
  
  
  }






//////////////////////////*****STORE A 2D ARRAY INTOA 1D ARRAY*************/



  void two2one_D(byte arr_1D[],byte  arr_2D[][(14+1)*4]){
    
    unsigned int x = 0;
       for(unsigned int i = 0; i< (num_of_rounds+1)*4; i++){
        for(unsigned int j = 0; j< 4; j++){
            arr_1D[x] = arr_2D[j][i];
            x++;
          }
      }
    
    }

      void two2one_D_message(byte arr_1D[],byte  arr_2D[][4]){
    
    unsigned int x = 0;
       for(unsigned int i = 0; i< 4; i++){
        for(unsigned int j = 0; j< 4; j++){
            arr_1D[x] = arr_2D[j][i];
            x++;
          }
      }
    
    }

String message;
String password;
char receivedMessage[16];
byte plaintext[16];
byte ciphertext[16];
byte initialKey[16];
byte AllKeys[4][60];
byte text[4][4];
byte wd[240];
int LCDRow = 0;
bool isMessageDone;
bool isTransmitting;
bool received;
void setup() {
 
keyb.begin(4);
Serial.begin(9600);
isReceiveKeyPressed = false;
isMessageDone = false;
isTransmitting = false;
received = false;
isPasswordDone = false;
pinMode(12,OUTPUT);
/*LCD setup*/
lcd.clear();
lcd.begin(16,2);
lcd.backlight();
lcd.setCursor(0,0);
lcd.print(F("TRANSMIT_KY:-"));
/*lcd.setCursor(0,1);
lcd.print(F("RETRIEVE_KY: +"));
lcd.setCursor(0,0);*/

}

/************************************Main function*****************************************/
void loop() {

/*Transmit();
Receive();
*/

if(Serial.readBytes(ciphertext,16))
    received = true;
 
    
     
if(received)
  {
    digitalWrite(12,HIGH);
    delay(1000);
    digitalWrite(12,LOW);
    lcd.clear();
    lcd.setCursor(0,0);
    lcd.print(F("unread message"));
    lcd.setCursor(0,1);
     lcd.print(F("press + to open"));
    
    }

if(keyb.available()){

  char letter = ' ';
  byte data = keyb.read();
  letter = KeyboardDecoder(data);
/**********MESSAGE RECEIVED HERE********/
  if(data == 121 && !(isTransmitting))//plus to receive
      {
        received=false;
        digitalWrite(12,LOW);
      isReceiveKeyPressed = true;
      LCDRow=0;
      password = "";
      lcd.clear();
      lcd.setCursor(0,0);
      lcd.print(F("Ent key: "));
      }

 if(data == 90 && isReceiveKeyPressed)//ENTER KEY1 
      {
        //received=false;
          //received=false;
        receiveData();
        
        }
       else if(isReceiveKeyPressed){
          //LCDRow=0;
          enterValues(letter, password);
          }
      /* receiveData();}*/

   if(isTransmitting){

      if(data == 90)//ENTER KEY1 to send
      {
        transmitMessage(isMessageDone);
        
        }

        //some trick here
      else if(!(isMessageDone))
          enterValues(letter, message);
      else if(isMessageDone){
         // LCDRow=0;
          enterValues(letter, password);
          message.getBytes(plaintext,16);
          }
      
   }

        if(data == 123)// minus to transmit
        {
          LCDRow =0;
          isTransmitting = true;
          lcd.clear();
          lcd.setCursor(0,0);
          lcd.print(F("Enter message: "));
          lcd.setCursor(LCDRow,1);
          
          }
    
  }

}






/*****************Values entered into arrays******/

void enterValues(char key, String storage){
  
  
  
  lcd.print(key);
  storage+=key;
  lcd.setCursor(++LCDRow,1);
  
  }







/*****************************************************************************************/
/*****************************************Transmit*****************************************/
void transmitMessage(bool messageStored)
{



  if(!messageStored){
    
      if(LCDRow == 0)
      lcd.print(F("Cannot send null"));
             else{
                    lcd.clear();
                    LCDRow = 0;
                    lcd.setCursor(LCDRow,0);
                    lcd.print(F("Enter key: "));
                    lcd.setCursor(LCDRow,1);
                    isMessageDone = true;
                    
                }
    
    }else{
      
          if(LCDRow == 0)
            lcd.print(F("Empty key"));
            else{
              
                 
                  isTransmitting = false;
                  isMessageDone = false;
                  lcd.clear();
                  lcd.setCursor(0,0);
                  lcd.print(F("Message was sent"));
                  password.getBytes(initialKey,16);
                  key_expansion(initialKey,AllKeys,Sbox);
                  one2two_D(plaintext,text);
                  Encryption(AllKeys,text);
                  two2one_D_message(ciphertext,text);
                  Serial.write(ciphertext,16);
                  message = "";

                  //////
              }
      }
 /* if(keyb.available())
{
  char letter = ' ';
  byte data = keyb.read();
 
 if (data == 90){
  
  Serial.write(message,16);
  LCDRow = 0;
  lcd.clear();
  lcd.setCursor(0,0);
  lcd.print("Sent");
  delay(1000);
  lcd.clear();
  //sendMessage = false;
 }


 // if(sendMessage)
//{
  letter = KeyboardDecoder(data);
   lcd.print(letter);
 //lcd.print(data);
  //byte a = HEX(data);
  message[LCDRow] =letter;
  LCDRow = LCDRow+1;
  if(LCDRow == 16)
  {
    lcd.setCursor(0,1);
  }
//}

 if(data==121){
    sendMessage = false;
  
  }


  //Serial.write(data);
  
  //Serial.println(data);

  
}*/



}



/******************************************************************************************/
/*****************************Receive*****************************************************/
void receiveData()
{   
    received = false;
    LCDRow = 0;
    lcd.clear();
    isReceiveKeyPressed =false;
    //lcd.setCursor(0,0);
    //lcd.print(F("Enter key: "));
    lcd.setCursor(LCDRow,1);
    two2one_D(wd,AllKeys);
    decryption(ciphertext,wd);
    message = "";

    for(int i=0; i<16; i++){
      
      message+=char(ciphertext[i]);
      }
    lcd.print(message);
 



}










/********************************************Keyboard decoder********************************/
char KeyboardDecoder(byte key)
{ 
  char deckey = ' ';
  if(key == 21)
  {
    deckey = 'Q';
  }else if (key == 29)
  {
    deckey = 'W';
  }else if (key == 36)
  {
    deckey = 'E';
  }else if (key == 45)
  {
    deckey = 'R';
  }else if (key == 44)
  {
    deckey = 'T';
  }else if (key == 53)
  {
    deckey = 'Y';
  }else if (key == 60)
  {
    deckey = 'U';
  }else if (key == 67)
  {
    deckey = 'I';
  }else if (key == 68)
  {
    deckey = 'O';
  }else if (key == 77)
  {
    deckey = 'P';
  }else if (key == 28)
  {
    deckey = 'A';
  }else if (key == 27)
  {
    deckey = 'S';
  }else if (key == 35)
  {
    deckey = 'D';
  }else if (key == 43)
  {
    deckey = 'F';
  }else if (key == 52)
  {
    deckey = 'G';
  }else if (key == 51)
  {
    deckey = 'H';
  }else if (key == 59)
  {
    deckey = 'J';
  }else if (key == 66)
  {
    deckey = 'K';
  }else if (key == 75)
  {
    deckey = 'L';
  }else if (key == 26)
  {
    deckey = 'Z';
  }else if (key == 34)
  {
    deckey = 'X';
  }else if (key == 33)
  {
    deckey = 'C';
  }else if (key == 42)
  {
    deckey = 'V';
  }else if (key == 50)
  {
    deckey = 'B';
  }else if (key == 49)
  {
    deckey = 'N';
  }
  else if (key == 58)
  {
    deckey = 'M';
  }
   else if (key == 41)
  {
    deckey = ' ';
  }


  return deckey;
}

/**************************************************************************************/
/*/////////////////////////////////////////////////////////////////////////////////*/
  
